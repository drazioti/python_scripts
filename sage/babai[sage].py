"""

 AUTHORS: K.Draziotis (26-5-2014): initial version
 
Babai algorithm for solving Closest Vector Problem-CVP using Sagemath routines called from native python
usage $./babai_3 x foo
where x is equal to 0 or 1.
If x=0, then foo=[[...],..,[....]]:matrix [....]:target vector
If x=1, then foo is a txt file which contains a matrix and the target vector as previous, but there is a blank line between them
Example : $./babai 0 [[1,2],[3,4]] [0,45]
          $(0,46)
          $./ babai 1 matrix
where matrix is the file : 
[[2,3,4,5,4,5,6,7],[1,-9,-5,3,-1,-2,-3,4],[1,90,89,78,56,45,12,34],[12,345,654,789,543,1234,-56,-7],[2,-3,-4,-5,-1,-2,-3,-4],
[1,90,89,78,67,56,45,34],[-4567,45,67,89,12,54,43,32],[90,78,98,78,67,12,34,56]]

[1,0,0,0,1,2,3,5]
we get   
          $(4, 0, 0, 0, 3, 3, 3, 3)
"""
#*****************************************************************************
#       Copyright (C) 2014 K.Draziotis <drazioti@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************


#!/usr/lib/sagemath/sage -python
import sys
from sage.all import *
if sys.argv[1]=="1":
  if len(sys.argv) != 3:
     print "Usage : %s foo,(where the text file foo contains two lines the first is a matrix of the form [[   ],...,[   ]] and the second is the target vector of the form [   ]. Note that there must be a blank line between the matrix and the target vector. "%sys.argv[0];
     print "Outputs, the closest vector to target vector of the lattice generated by the rows of M, using Babai's algorithm."
     sys.exit(1)
  f=open(sys.argv[2])
  a1=f.readline()
  f.readline()
  b1=f.readline()
  M3=matrix(sage_eval(a1));
  rank=int(M3.nrows());
  dim=int(M3.ncols());
  if rank>dim:
    print "Error : linear dependent vectors"
  r=[];
  L=[];
  Y=[];
  babai=[];
  target=vector(sage_eval(b1));
  f.close
if sys.argv[1]=="0":
  if len(sys.argv) != 4:
    print "Usage: %s <matrix> <targer vector>"%sys.argv[0];
    print "Outputs the closest vector to target_vector of the lattice generated by the rows of M, using Babai's algorithm."
    sys.exit(1)
  M3=matrix(sage_eval(sys.argv[2]));
  rank=int(M3.nrows());
  dim=int(M3.ncols());
  if rank>dim:
    print "Error : linear dependent vectors"
    sys.exit(1)
  r=[];
  L=[];
  Y=[];
  babai=[];
  target=vector(sage_eval(sys.argv[3]));
if sys.argv[1]!="0" and sys.argv[1]!="1":
  print "Usage : %s x foo, where x is equals to 1 if your inpout is from a file, or 0 if not, and foo is either a text file or a mtrix with a vector. "%sys.argv[0];
  sys.exit(1)
w=vector([0 for i in range(0,dim)]);
##########
#  First step. We reduce the rowspace of A with LLL and delta = 3/4
##########
AA=M3.LLL(delta=0.75,algorithm='NTL:LLL');
##########
#  Second step. Apply Babai to the reduced basis
##########
GM=AA.gram_schmidt()[0];
w=target
j=0;
i=0;
for j in range(rank):
    i=rank-j-1
    a=w.dot_product((GM[i]));
    bb=vector(GM[i]).dot_product(GM[i]);
    L=a/bb;
    Y.append(floor(L+.5)*AA.row(i));
    w=w-(L-floor(L+.5))*GM[i]-floor(L+.5)*AA.row(i);
babai=sum(Y);
print(babai);
sum(Integer((babai[i]-target[i]))^2 for i in range(dim));

